1. Mesh生成：用的是clip map，平滑后的clipmap

Interior, Fat, FatX, FatXSlimZ, FatXOuter, FatXZ, FatXZOuter, SlimX, SlimXZ, SlimXFatZ

#### Mesh生成考虑因素：

+ 铺满整个视椎体，顶点数要尽可能少。
+ 有足够的精度，合理的密度分布，近处顶点密度大，远处顶点密度小
+ 移动时，顶点密度要跟随相机变化，不能有跳变

需要一个顶点过渡平滑的lod系统，clipMap, 辅以 Vertex Morping （解决T-juctions问题）, Vertex Skirt.此外根据clipmap的特性，对顶点做了切分，使顶点数量降到最低。



#### 波形

1. 最简单的方式是采用sincos模拟的波形，需要多个函数叠加，但是波峰不够尖锐，比较圆滑。

2. Gerstner波形：解决了sincos波波峰圆滑的问题。但是也需要大量的波形函数叠加，波形还是不够真实

3. FFT海洋：

   时域图像：叠加出来的波形函数。

   频谱图像：将时域图像分解成不同频率不同振幅的正余弦函数，按照频率方向排布，振幅所组成的函数曲线图像

   **将时域转换为频域称为傅里叶变换**

   **将频域转换为时域称为逆傅里叶变换**

   ![](.\时域频域.png)

#### FFT原理：

离散傅里叶变换DFT公式
$$
F(\mu) = \sum_{x=0}^Nf(x)e^{-i\frac{2\pi\mu x}{N}}
$$
对$e^{-i\frac{2\pi\mu x}{N}}$进行欧拉展开后，可得
$$
F(\mu) = \sum_{x=0}^{N-1}f(x)cos(\frac{2\pi\mu x}{N}) - i\sum_{x=0}^{N-1}f(x)sin(\frac{2\pi\mu x}{N})
$$
三角函数的正交性：组成三角级数的1, cosx, sinx, cos2x, sin2x....其中任意连个不同的函数之积，在公共周期内积分等于0。在上面的公式中，对时域$f(x)$进行两个检波器检测，分别过滤掉其他频率的振幅，可得到一个复数，复数的模就是对应频率$\mu$的振幅。

逆离散傅里叶变化公式IDFT有DFT推导得到：
$$
f(x) = \frac{1}{N}\sum_{\mu=0}^{N-1}F(\mu)e^{i\frac{2\pi\mu x}{N}}
$$


#### FFT海洋公式

​	要想得到一个复杂的海面，需要生成频谱，然后通过逆离散傅里叶变换，就可以得到由很多不同频率，振幅波形叠加出来的复杂海面，频谱决定海面的形状。

​	流程：生成频谱（高度频谱，偏移频谱(x,z方向)---->进行逆离散傅里叶变换---->生成displacement map进行渲染。

逆傅里叶变换计算一个位置的复杂度是$O(NM)$。如果循环计算，时间复杂度是$O(N^2M^2)$。所以需要进行新的快速傅里叶变化。快速傅里叶变换采用的蝴蝶算法，预计算好FFT过程中用到的索引和系数，存储到相应的纹理之中，运行时使用。分别需要进行横向IFFT和纵向IFFT两次运算，输出displacement map，xyz中分别存储高度以及xz方向上的偏移。

#### 处理Tiling：

生成的displacement map大小有限，需要合适的tiling方案。

前面的clipmap生成了不同精度的网格。

每一级网格能够表达的频率范围不同，近处网格能显示更多的细节，远处比较少。

方案是为每一级LOD都生成一张displacement map。前面会针对不同长度的波浪生成displacement map。当为每一级LOD生成displacement map时，首先确定该级LOD能否显示对应长度的波浪，如果可以，根据合适的比例，将该波长的displacement附加到该层级的LOD上。为了简化计算，先计算高级别LOD，然后计算低级别LOD的displacement map，可以复用部分长度比较大的浪花结果。

### 渲染：

每一级LOD都生成了对应的displacement map。对于LOD边界处，为了避免突变，需要采两级LOD，然后对结果进行lerp。

##### 光照：

法线生成：取三个点位，计算高度差，cross得出法线向量

浮沫数据：根据生成的浮沫数据，采用雅克比公式计算

漫反射：

镜面反射,高光：

细节法线贴图

折射

通透感：sss， 基于深度查表

sss：首先根据displacement map来计算这个点是不是波峰，然后根据视角方向和光照方向决定是否是背光面，只有背光面才有sss，最后还要叠加viewDir.y.越小，sss效果越明显

白沫数据：

planrReflection:

scatterCol: sss 效果，

emissionCol: 水的通透性，显示水底效果

skyCol:

#### 交互：

略

#### 物理计算：

目前采用Compute Shader回读高度数据，读出对应点的displacement，normal， velocity信息数据。

对于上下浮力，通过高度数据向rb施加力

对于drag浮力，通过rb.velocity 跟 water Velocity的差值，来对rb施加力。

最后通过normal来计算扭矩torque