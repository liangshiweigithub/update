1.存储开销：4km的地图，草的数量千万级。带来巨大的存储开销和场景加载卡顿。

2.美术编辑工作复杂。

运行时开销:

1. 200 ~ 300 m左右的场景会有数十万乃至上百万棵草的渲染。CPU压力（裁剪，instance数据提交开销）大
2. GPU处理几十万个顶点的压力。带来显著的性能问题。
3. overdraw严重。alpha test表现叶子的复杂结构，能看见的像素只是实际填充像素的很小一部分。GPU压力大

老方案：

1. 降低instance数量。

   将地表划分成一个个的格子，使用规则的正方向地表植被patch来降低instance数量。（平铺重复感通过镜像解决）。

2. 密度图来控制植被密度变化。通过密度图来丢弃patch内的部分草和全部的草，vs中clip顶点来实现。对于Base模型，每个顶点上记录了其对应的权重，该值低于密度值，激动到视锥之外。Lod模型在pixel中剔除（缺点，跟alpha test一样）

3. LOD 插片。井子型插片，将模型信息烘焙到插片上，生成其lod

问题：

1. 视角过高，lod很容易穿帮，增大base显示距离又会导致面数激增。
2. 控制粗糙，地形复杂后有贴地问题
3. lod光照比较难调整，调整不好有明显的分界线，各种trick参数
4. vs中的压力还是有些大

新方案：

​    还是基于密度图来生成草的数据。

1. CPU运行时动态种草。需要密度图和高度图信息。地表还是划分为一个个的格子，位置移动时，对新进入视野的格子进行“种草”，随机生成位置和一个密度值，取密度图中该点的位置，如果相比较大，则生成草的 instance data。

2. 面数控制：

   1. 特殊的三插片模型。
   2. 基于距离的密度衰减:
      1.  设定显示层级。
      2. 根据Grid中instance的数量和层级，决定每一级显示的instance数量（线性衰减，二次衰减等）
      3. 根据相机位置和视角，决定显示的level，确定要显示的instance数量。level变化时，dither in/out平滑切换，同时配合地表染色，基本看不出来突变。
   3. instance data压缩: postion xyz,  scale(uint8), rotation(uint8)
4. 缩放跟当前点的密度有关
   
   既能保证较好的效果，又能使开销可控。缺陷？