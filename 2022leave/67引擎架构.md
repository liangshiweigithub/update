#### 流程：

+ UE编辑场景，通过导出插件导出到Messiah中，生成Messiah可编辑场景，在可编辑场景里面进行效果微调和bug修复。Messiah可编辑场景经过SceneFactory线下处理工具，生成运行时场景，运行时场景不可编辑。

  ##### 导出插件

  提供场景输出功能，包括模型等资源的输出，场景信息输出等。对导出插件进行各种修改，导出UE场景时进行定制

  + HLOD的导出。契合引擎提供的代理模型功能。导出时按照引擎的要求切分关卡，并设置到代理关系。HLOD模型一开始UE中自动生成，效果一般，后续改为美术制作，即控制了场景中的面，又保证了良好的显示效果。

  ##### SceneFactory生成运行时场景：

  这个工具会加载编辑器场景，进行一些处理，比如合图操作，为没有lightmap的物体（植被，可破坏物)等生成一个粗糙的离线shadowRate，生成打包图片相关的配置参数等等，最后输出运行时场景所需要的各种信息。

#### Data Oriented Design

1. LOD切换：改为了基于屏幕空间占比的切换方式。
2. SceneFactory平展了lod模型信息，不再有LOD的概念。平展后输出场景的mesh数据数组，材质数据数组，Lod配置数组，和一个RenderObjects数组。RenderObject数组会索引前面三个数组的内容，想相关的信息输出为一个Raw data的二进制文件。
3. 加载场景中会加载这个文件，根据DOD的设计原理，需要数据进行关联性存储，以提高缓存命中率。加载时，然后把RenderObject内的数据按照用途分开，作为Entity的各个Component的数据。比如一个Entity可能有如下的Component：
   + BoundingComponent: 存储用于裁剪的包围球或者包围盒信息
   + RenderObjectInfoCoponent:存储用于绘制的材质和mesh相关信息
   + LODConfigComponent：存储用于LOD切换的相关信息
   + InstanceDataComponent: 存储instance data相关的信息。
4. ECS的实现。加载数据时会为每个生成的RenderObject创建一个Entity。Entity下挂着各种component。每个component有一个id，id组合成EntityType。Entity的数据组织方式：Component的数据顺序存储。比如显示所有Entity的BoundingSPhere相关的数据，然后是LODConfigComponent相关的数据，不同Entity的相同类型的component data连续存储，形成SOA存储架构
5. System：很多泛化的System，并不一定叫某某System。用于绘制的ModelRender和FoliageRender都可以看作是System。这些Render利用EntitySystem提供的遍历方法，指定一个或多个Component类型，去遍历相应的Entity的Component， 拿到相应的数据进行处理。
6. 为了配合ECS系统，重构了引擎模型组件和管线。引入了引擎层面的各种Component，负责创建对应的entity，并添加合适的Component。比如
   + H67ModelComponent负责加载场景中模型，并创建场景中的模型对应的entity，并设置其数据的Component，进行状态同步。
   + H67MeadowComponent负责创建场景中草地相关的entity
   + H67TerrainComponent负责创建场景中地形相关的entity。
7. 与各个component配合，实现了一系列的Render来负责进行裁剪，处理lod，合批，提交渲染等相关的工作，比如ModelRender，FoliageRender等等。

#### 优势：

+ 相关数据连续存储，提升缓存命中
+ Collect的逻辑与之前相比大幅简化
+ LOD被平展，使得合批，SPMD culling实现更简单
+ 不同Render调用Collect的时机完全可控，方便定制其他系统。

#### 我认为