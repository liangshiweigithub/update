1.数据库的封锁：
  封锁的粒度：行级锁和表级锁。锁定数据越少，锁争用的可能性越小，系统并发程度越高。
 
2.读写锁
(1)排它锁，写锁
(2)共享锁，读锁

3.意向锁：更容易的支持多粒度封锁。当只有读写锁时，要想对表A加X锁，需要检测每一行以及表A的锁，很耗时。
  意向锁在X/S锁的基础上引入了IX/IS锁，都是表锁
  加锁过程：
   (1)一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或IX锁
   (2)一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁
  任意IS/IX锁之间兼容，只是表示想要对表加锁。S锁与S锁和IS锁兼容。
  通过引入意向锁，事务T想对表A加X锁，首先检测是否有其他事务对表A加了X/IX/S/IS锁，如果有就表示有其他事务正在
  使用这个表或表中一行，事务T加锁失败。

4.三级封锁协议：
 (1)一级封锁协议：事务T想要修改数据A时必须加X锁，直到事务结束释放锁。可以解决丢失修改的问题，
    不会有两个事务对同一个数据修改，修改就不会覆盖。
 (2)二级封锁协议：一级的基础上，读取数据A时必须加S锁，读取完马上释放，可以解决度脏数据问题。
 (3)三级封锁协议：二级的基础上，读取数据A时必须加S锁，直到事务完成才能释放，可以解决不可重复读的问题。
 
5.两段锁协议：加锁解锁分两个阶段进行。
  可串行化调度：通过并发控制，使得并发执行事务的结果与串行执行的结果相同。
  事务遵循两段锁协议是保证可串行化调度的充分条件
  
6.隔离级别
 (1)未提交读，READ UNCOMMITED, 事务的修改，即使没有提交，其他事务也是可见的
 (2)提交度，READ COMMITTED,一个事务所做的修改在提交之前对其他事务是不可见的
 (3)可重复度，REPEATABLE READ，保证同一个事务中多次读取结果是一样的。
 (4)可串行化，SERIALIZABLE，强制事务串行执行