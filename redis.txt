1.redis中zset实现原理：
	跳跃表，基于多指针有序链表实现，可以看成多个有序链表。查找时，从上层指针开始查找，找到对应区间后再到下一层查找。
	跳跃表有点
	1.插入快速，不需要旋转等操作维护平衡性。与红黑树相比较
	2.实现容易，支持无锁操作

2.redis内存不足解决方案：
（1）增加内存
（2）使用redis的内存淘汰策略。
	redis支持为每个键设置过期时间，当键过期的时候，自动删除该键
	数据淘汰策略：volatile-lru,volatile-ttl,volatile-random,allkeys-lru,allkeys-random,noeviction。
	4.0后支持volatile-lfu, allkeys-lfu,访问频率最少的键值删除。
（3）redis集群。三种方式：客户端分片（自己控制分片算法，维护成本高），代理分片（性能消耗，单点效应），
	redis cluster（无中心节点，性能好，方案太重，无法平滑扩容，缩容）

3.缓存穿透：查询一个数据库一定不存在的数据，导致每次都会查询数据库，压垮数据库。
  解决方案：从数据库查询的数据为空时，也放入缓存，但是要设置一个过期时间。
 
4.缓存雪崩：某一个时间段，缓存集中过期失效，原缓存失效，新缓存为到，数据库会产生周期性压力波峰。
	（1）缓存数据集中失效：为缓存数据设置不同的失效时间。或者通过加锁或者队列来控制数据库写缓存的线程数量，其他线程等待
		一个key只能一个线程操作。
	（2）缓存服务器的节点宕机或者断网。
		[1]使用分布式缓存
		[2]进行缓存预热，避免系统刚启动不就由于还未将大量数据进行缓存二导致雪崩。
  缓存预热：系统上线后，将相关的缓存数据直接加载到缓存

5.缓存击穿：缓存中没有但数据库中有的数据（缓存到期），并发用户特多，引起数据库压力瞬间增大。
	热点数据永不过期。互斥锁
	
6.redis限流：
	开发高并发系统时，需要多种手段保护系统。
	缓存：提升访问速速。
	降级：暂时屏蔽掉非核心业务，使核心也不不受影响。
	限流：对并发访问进行限速，达到一定速率就可以拒绝服务(定向到错误页或告知资源没有了)，排队等待(秒杀，评论，下单)，降级。

 限流方式：
	信号量：达到permit上限前，qps上升毫无阻力，瞬间的qps可以达到极大值
	计数器: 限制单位时间请求数量，达到上限，触发限流，一点时间间隔后重置可请求数（访问不均匀问题），
	滑动窗口（粒度更小的计数器），
	漏桶算法：水(请求)进入漏桶，漏桶以一定的速率出水(接口的响应速率)，水过多时直接溢出，然后就拒绝请求，该算法能强行显示数据传输速率。
	    缺点：漏出速率固定，对于存在突发特性的流量来说缺乏效率
	令牌桶：以固定速率向令牌桶中放入令牌，请求进来时，从桶中取走令牌，桶中令牌为空时，触发限流
	     与漏桶算法相比，支持分布式限流，对突发性的流量支持比较好

		 
 redis分布式限流。
   redis优势：效率高，易扩展，单进程单线程可以更好的解决最终一致性，多进程间协同控制更容易。  
	
	参考：https://blog.wangqi.love/articles/Java/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88.html
	
7.redis热点问题：用户频繁访问分区中的相同key称为热点。
产生原因：
	1.用户消费数据远大于生产的数据（热卖商品，热点新闻等，突发事件：降价商品促销等）
	2.请求切片数超过单个服务器性能阈值。在服务器上访问一条数据时，通常会对数据进行拆分或者切片。
危害：
	流量集中，达到物理网络适配器的上限。
	请求排队过多，导致缓存分片服务雪崩。热点分布过于密集，会缓存大量热点，从而耗尽缓存容量导致缓存的分片服务崩溃。
	数据库过载。
	解决后续添加
	https://zhuanlan.zhihu.com/p/50668153

8.redis事务：redis命令的集合。
执行事务中的错误：1.入队错误 2.执行错误
实现：MULTI：开启一个事务，执行后，客户端可以向服务器发送多条命令，缓存到队列中
      EXEC：开始执行事务。返回一个数组，包含执行命令的状态。
	  DISCARD：放弃事务，清空事务队列，从事务状态退出
	  WATCH:为Redis事务提供check-and-set的行为。被watch的键会被监视，如果有至少一个被监视的键在WATCH之后，EXEC执行前被修改，整个事务会被取消，
		EXEC返回多条 null nulti-buld reply标识事务失败。这种形式的所被称为乐观锁。
对于入队错误，执行EXEC时，报错回滚所有命令，终止事务。
遇到执行错误，与mysql不同，放过，保证事务执行完成，不会进行回滚，使用时要自己保证逻辑符合预期。



9.redis一致性哈希算法：将哈希值空间组织成一个虚拟的圆环，解决传统哈希分布在服务器节点数量
  数量变化是大量的数据迁移问题，容错性和扩展性问题。
  方式：
	将哈希空间看成一个环，服务器节点配置到哈希环上，获得对象的hash值后，
	存放到哈希环顺时针第一个大于等于该哈希值的节点上。
  优势：增加或者删除节点只会影响到哈希环中相邻的节点。容错性扩展性得到保障。
  如果节点在哈希环上分布不均匀，可能会导致数据分布不均匀，可以通过增加虚拟节点，
  然后将虚拟节点映射到真实节点上解决
  
10.redis分布式锁：分布式锁一般有三种实现方式，数据库乐观锁，基于redis的分布式锁和基于Zookeeper的分布式锁
 分布式锁满足的条件:
  (1)互斥性，任意时刻，只有一个客户端有锁。
  (2)不会死锁，加锁客户端崩溃时，其他客户端能继续加锁。
  (3)容错性，大部分redis节点正常运行，客户端就可以加锁解锁
  (4)解锁唯一性，保证加锁解锁是同一个客户端。
 
 加锁：
 方式：set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expire_time)
   redis 自带的setNX指令无法指定过期时间。
   如果key对应的value作为过期时间，会出现解锁不一致问题。
   
错误示范 
代码：
   public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) {
 
    long expires = System.currentTimeMillis() + expireTime;
    String expiresStr = String.valueOf(expires);
 
    // 如果当前锁不存在，返回加锁成功
    if (jedis.setnx(lockKey, expiresStr) == 1) {
        return true;
    }
 
    // 如果锁存在，获取锁的过期时间
    String currentValueStr = jedis.get(lockKey);
    if (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {
        // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
        String oldValueStr = jedis.getSet(lockKey, expiresStr);
        if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {
            // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁
            return true;
        }
    }
 
    // 其他情况，一律返回加锁失败
    return false;
 
}
会有以下问题
   客户端自己生成过期时间，每个客户端时间必须同步。
   锁过期时，过个客户端同时getSet，最终虽然只有一个客户端加了锁，但是过期时间可能被覆盖
   没有标识，任何客户端都可以解锁。
   
 解锁：
	解锁步骤：
	1.检测上面设置的锁值是否与自己相同，2.是的话删除。要保证这两步操作的原子性。通常用eval，或者MULTI执行？
错误示例：	

public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) {
    // 判断加锁与解锁是不是同一个客户端
    if (requestId.equals(jedis.get(lockKey))) {
        // 若在此时，这把锁突然不是这个客户端的(如过期了，然后其他人加了锁)，则会误解锁
        jedis.del(lockKey);
    }
}
 参考文献：http://www.importnew.com/27477.html
 

11.redis的使用模式：
  (1)单点模式，一个redis实例
  (2)主从模式，多个实例，1主N从，主读写，从只读，master挂了，slave不会竞选成为master
  (3)哨兵模式，与主从模式相比，可以选举slave成为master，一个sentinel可管理多个主从Redis，该模式下
     连接的是sentinel，由sentinel来提供具体可以提供服务的Redis实例
	Sentinel集群：Sentinel进程可发现监视相同实例的其他sentinel。
	集群中的Sentinel不会在同一时刻failover(故障切换or故障转移)同一个master，除非有sentinel失败。完成操作后广播，其他sentinel更新配置。
  (4)集群模式：多主多从。当数据量达到一台服务器存不下时，主从或者sentinel模式就不能满足了。需要对存储的数据分片，存储到对个redis实例中。	
     一个集群包含16384个哈希槽，每个节点负责一部分哈希槽。对节点使用了主从复制功能。主节点挂掉时，从节点通过心跳监听，
	 竞选成为主节点。
	 
12.Redis与MemeCached：数据类型，持久化，分布式，内存管理机制

13.redis为什么这么快：
(1)完全基于内存，数据在内存中。
(2)数据结构简单高效，很多数据结构经过专门的设计。
(3)单线程避免了不必要的上下文切换和竞争条件，不用考虑加锁解锁的消耗。
(4)I/O多路复用，非阻塞IO
(5)构建了自己的VM机制。
多核CPU时，可开多个Redis实例。这里的单线程指的是处理网络请求的时候。
参考：https://juejin.im/entry/5b7cfe976fb9a01a13366d95

14.redis的RedLock：使用多个redis实例获取锁，保证在发生单点故障时仍然可用。
  1.设定一个过期时间。
  2.尝试从N个相互独立的Redis实例获取锁。在限定的过期时间内，从一半以上的redis实例中获取了锁，则认为加锁成功。否则失败