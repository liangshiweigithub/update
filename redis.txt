1.redis中zset实现原理：
	跳跃表，基于多指针有序链表实现，可以看成多个有序链表。查找时，从上层指针开始查找，找到对应区间后再到下一层查找。
	跳跃表有点
	1.插入快速，不需要旋转等操作维护平衡性。与红黑树相比较
	2.实现容易，支持无锁操作

2.redis内存不足解决方案：
（1）增加内存
（2）使用redis的内存淘汰策略。
	redis支持为每个键设置过期时间，当键过期的时候，自动删除该键
	数据淘汰策略：volatile-lru,volatile-ttl,volatile-random,allkeys-lru,allkeys-random,noeviction。
	4.0后支持volatile-lfu, allkeys-lfu,访问频率最少的键值删除。
（3）redis集群。三种方式：客户端分片（自己控制分片算法，维护成本高），代理分片（性能消耗，单点效应），
	redis cluster（无中心节点，性能好，方案太重，无法平滑扩容，缩容）

3.缓存穿透：查询一个数据库一定不存在的数据，导致每次都会查询数据库，压垮数据库。
  解决方案：从数据库查询的数据为空时，也放入缓存，但是要设置一个过期时间。
 
4.缓存雪崩：某一个时间段，缓存集中过期失效，数据库会产生周期性压力波峰。
	（1）缓存数据集中失效：为缓存数据设置不同的失效时间。或者通过加锁或者队列来控制数据库写缓存的线程数量，其他线程等待
		一个key只能一个线程操作。
	（2）缓存服务器的节点宕机或者断网。
		[1]保持缓存服务器的高可用行。哨兵机制，剔除有问题的服务器。
		[2]依赖隔离组件为后端限流并降级

5.缓存击穿：缓存中没有但数据库中有的数据（缓存到期），并发用户特多，引起数据库压力瞬间增大。
	热点数据永不过期。互斥锁
	
6.redis限流：
	开发高并发系统时，需要多种手段保护系统。
	缓存：提升访问速速。
	降级：暂时屏蔽掉非核心业务，使核心也不不受影响。
	限流：对并发访问进行限速，达到一定速率就可以拒绝服务，排队等待，降级。
限流方式：
	信号量：达到permit上限前，qps上升毫无阻力，瞬间的qps可以达到极大值
	计数器（访问不均匀问题），
	滑动窗口（粒度更小的计数器），
	漏桶，
	令牌桶，
	分布式限流。
    (1)计数器。限制在指定时间内只允许发生N次事件。通过zset的score值，圈出一个时间窗口，计算窗口内事件发生的数量。
	zset为空时自动内存中移除，所以非活跃用户没有数据记录，降低了内存消耗
	(2)令牌桶，以固定速率向令牌桶中放入令牌，请求进来时，从同种取走令牌，桶中令牌为空时，触发限流
	参考：https://blog.wangqi.love/articles/Java/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88.html
	
7.redis热点问题：用户频繁访问分区中的相同key称为热点。
产生原因：
	1.用户消费数据远大于生产的数据（热卖商品，热点新闻等，突发事件：降价商品促销等）
	2.请求切片数超过单个服务器性能阈值。在服务器上访问一条数据时，通常会对数据进行拆分或者切片。
危害：
	流量集中，达到物理网络适配器的上限。
	请求排队过多，导致缓存分片服务雪崩。热点分布过于密集，会缓存大量热点，从而耗尽缓存容量导致缓存的分片服务崩溃。
	数据库过载。
	解决后续添加
	https://zhuanlan.zhihu.com/p/50668153

8.redis事务：redis命令的集合。
执行事务中的错误：1.入队错误 2.执行错误
实现：MULTI：开启一个事务，执行后，客户端可以向服务器发送多条命令，缓存到队列中
      EXEC：开始执行事务。返回一个数组，包含执行命令的状态。
	  DISCARD：放弃事务，清空事务队列，从事务状态退出
	  WATCH:为Redis事务提供check-and-set的行为。被watch的键会被监视，如果有至少一个被监视的键在WATCH之后，EXEC执行前被修改，整个事务会被取消，
		EXEC返回多条 null nulti-buld reply标识事务失败。这种形式的所被称为乐观锁。
对于入队错误，执行EXEC时，报错回滚所有命令，终止事务。
遇到执行错误，与mysql不同，放过，保证事务执行完成，不会进行回滚，使用时要自己保证逻辑符合预期。



9.redis一致性哈希算法：将哈希值空间组织成一个虚拟的圆环，解决传统哈希分布在服务器节点数量
  数量变化是大量的数据迁移问题，容错性和扩展性问题。
  方式：
	将哈希空间看成一个环，服务器节点配置到哈希环上，获得对象的hash值后，
	存放到哈希环顺时针第一个大于等于该哈希值的节点上。
  优势：增加或者删除节点只会影响到哈希环中相邻的节点。容错性扩展性得到保障。
  如果节点在哈希环上分布不均匀，可能会导致数据分布不均匀，可以通过增加虚拟节点，
  然后将虚拟节点映射到真实节点上解决
  
  https://blog.wangqi.love/articles/Java/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88.html
 https://www.jianshu.com/p/a3d068f2586d
 https://segmentfault.com/a/1190000012947169
  
10.redis分布式锁：分布式锁一般有三种实现方式，数据库乐观锁，基于redis的分布式锁和基于Zookeeper的分布式锁
 分布式锁满足的条件:
  (1)互斥性，任意时刻，只有一个客户端有锁。
  (2)不会死锁，加锁客户端崩溃时，其他客户端能继续加锁。
  (3)容错性，大部分redis节点正常运行，客户端就可以加锁解锁
  (4)解锁唯一性，保证加锁解锁是同一个客户端。
 
 加锁：
 方式：set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expire_time)
   redis 自带的setNX指令无法指定过期时间。
   如果key对应的value作为过期时间，会出现解锁不一致问题。
   
错误示范 
代码：
   public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) {
 
    long expires = System.currentTimeMillis() + expireTime;
    String expiresStr = String.valueOf(expires);
 
    // 如果当前锁不存在，返回加锁成功
    if (jedis.setnx(lockKey, expiresStr) == 1) {
        return true;
    }
 
    // 如果锁存在，获取锁的过期时间
    String currentValueStr = jedis.get(lockKey);
    if (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {
        // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
        String oldValueStr = jedis.getSet(lockKey, expiresStr);
        if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {
            // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁
            return true;
        }
    }
 
    // 其他情况，一律返回加锁失败
    return false;
 
}
会有以下问题
   客户端自己生成过期时间，每个客户端时间必须同步。
   锁过期时，过个客户端同时getSet，最终虽然只有一个客户端加了锁，但是过期时间可能被覆盖
   没有标识，任何客户端都可以解锁。
   
 解锁：
	解锁步骤：
	1.检测上面设置的锁值是否与自己相同，2.是的话删除。要保证这两步操作的原子性。通常用eval，或者MULTI执行？
错误示例：	

public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) {
    // 判断加锁与解锁是不是同一个客户端
    if (requestId.equals(jedis.get(lockKey))) {
        // 若在此时，这把锁突然不是这个客户端的(如过期了，然后其他人加了锁)，则会误解锁
        jedis.del(lockKey);
    }
}
 参考文献：http://www.importnew.com/27477.html
 

11.redis的使用模式：
  (1)单点模式，一个redis实例
  (2)主从模式，多个实例，1主N从，主读写，从只读，master挂了，slave不会竞选成为master
  (3)哨兵模式，与主从模式相比，可以选举slave成为master，一个sentinel可管理多个主从Redis，该模式下
     连接的是sentinel，由sentinel来提供具体可以提供服务的Redis实例
	Sentinel集群：Sentinel进程可发现监视相同实例的其他sentinel。
	集群中的Sentinel不会在同一时刻failover(故障切换or故障转移)同一个master，除非有sentinel失败。完成操作后广播，其他sentinel更新配置。
  (4)集群模式：多主多从。当数据量达到一台服务器存不下时，主从或者sentinel模式就不能满足了。需要对存储的数据分片，存储到对个redis实例中。	
     一个集群包含16384个哈希槽，每个节点负责一部分哈希槽。对节点使用了主从复制功能。主节点挂掉时，从节点通过心跳监听，
	 竞选成为主节点。
	 
12.Redis与MemeCached：数据类型，持久化，分布式，内存管理机制