1.java中的sleep和wait
  (1)sleep来自Thread类，谁调用谁进入休眠状态，wait来自Object类
  (2)sleep没有释放锁，wait方法释放了锁，wait后，等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，进入等待队列。
  (3)wait，notify和notifyAll只能在同步控制方法或者同步块里使用，sleep可在任何地方使用，无需捕获异常。
  
2.内存溢出和内存泄漏：
  (1)内存溢出(out of memory):程序申请内存时，没有足够的内存空间供其使用，要求分配的内存超出了系统能给的。如一次性往内存中加载了过多的数据。
  (2)内存泄漏(memory leak):程序申请内存后，没有释放分配的内存空间。
  
3.Linux命令篇：
  df -k(-m)；以KB或者MB为单位查看内存使用情况。
 内存查看工具：
 (1)top:各个进程单独显示
 (2)free：总体使用情况
 (3)cat /proc/meminfo 最完整的
 (4)ps aux -sort --rss
 IO状态查看：iostat
 
4.页面置换算法:LRU,FIFO,OPT(最佳置换法)，时钟算法。

5.查看进程占用端口：
  netstat
 
6.进程同步方式：
  进程同步是让进程按一定顺序执行，进程通信是进程间传递信息，进程通信时手段，进程同步是目的，为了达到同步的目的，需要通信。
 (1).临界区：对临界资源(互斥访问的资源)进行访问的代码
 (2).同步和互斥：同步：多个进程按一定顺序执行。互斥：多个进程同一时刻只有一个能进入临界区。
 (3).信号量：整形变量，可执行P和V操作。
 (4).管程：一个时刻只能有一个进程使用管程。
 
7.进程通信的方式：
 (1).管道：半双工通信，只能在父子进程中使用。
 (2).FIFO：命名管道，除去了只能在父子进程间使用的限制。
 (3).消息队列：
     可以独立读写进程存在，避免FIFO中打开关闭可能产生的困难。
	 避免了同步阻塞的问题，不需要进程提供同步方法
	 读进程可以根据根据消息类型有选择的接收消息。
 (4).信号量：本质是一个计数器，用于为多个进程提供对共享数据对象的访问。
 (5).共享存储：允许多个进程共享一个给定的存储区，无需数据复制，最快，需要信号量控制对共享存储的访问。
 (6).套接字：用于不同机器进程间的通信。
 
8.线程的同步和互斥：同步是通过特定的设置，控制执行的顺序。互斥是指访问共享资源时的排他性。互斥可看成时一种特殊的同步。
(1).临界区：多线程串行化来访问公共资源或代码，执行的关键段有初始化，销毁，进入，离开四个函数。可以解决互斥问题，无法解决同步问题。
(2).互斥对象：只有拥有互斥对象的线程才有访问公共资源的权限。
(3).信号量：允许多个进程同一时刻访问同一资源，有最大线程数目的限制。
(4).事件对象：通过通知操作的方式来保持线程同步，方便实现对多个线程的优先级比较操作。
临界区，互斥对象用于互斥控制，信号量，事件对象以通知的方式进行控制，主要用于同步控制。


9.堆分配的空间在逻辑地址上是连续的，但在物理地址上是不连续的（因为采用了页式内存管理,windows下有段机制、分页机制），
  如果逻辑地址空间上已经没有一段连续且足够大的空间，则分配内存失败。
  
10.Linux中文件存储在扇区组成的快中，需要一个地方存储文件的元信息，(如文件的创建者，创建日期，大小，所有者的User ID， Group ID)。
   存储文件元信息的区域叫做inode，即索引节点.硬盘格式化时分成两个区，一个是数据区，另一个是存放inode信息的inode区。
   读取过程：根据文件名获取对应的inode号码，获取inode信息后获取文件信息