创建型：

1.单例模式：
 (1)懒汉式：线程不安全方式: static变量和static获取函数，为加锁
 (2)饿汉式：线程安全：定义时直接初始化静态成员变量。
 (3)懒汉式线程安全：整个getInstance函数锁定。
 (4)双重校验机制。判空->加锁->判空->实例化。
 
2.简单工厂模式(Simple Factory)：创建一个对象时不向客户暴露内部细节，提供创建对象的通用接口，单个工厂里面生产多个类实例。

3.工厂方法(Factory Method):定义了创建对象的接口，但由子类决定要实例化哪个类，每个子类负责一个类的实例化。

4.抽象工厂(Abstract Factory):提供创建相关的对象家族的接口，创建的对象是相关的，上面的方法只创建一个对象。

5.生成器(Builder):封装一个对象的构造过程，并允许按步骤构造。

6.原型模式(Prototype)：使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象，类里面提供类的复制方法。


行为型
1.责任链(Chain Of Responsibility)：使多个对象都有机会处理请求，避免请求发送者和接受者之间的耦合关系。将对象连成一条链，
    沿着链条发送请求，知道有对象处理为止。

2.命令模式(Command):将命令封装成对象，可以使用命令参数化其他对象，将命令放在队列中排队，将命令记录到日志中，支持可撤销的操作。

3.解释器(Interpreter):为语言创建解释器。

4.迭代器(Iterator):提供顺序访问聚合对象元素的方法，并且不暴露聚合对象内部表示。

5.中介者(Mediator):集中相关对象之间复杂的沟通和控制方式。

6.备忘录(Memento):在不违反封装的情况下获得对象的内部状态，在需要时可以将对象恢复到最初状态。

7.观察者(Observer):定义对象间一对多依赖，一个对象状态改变时，所有依赖都会受到通知并自动更新状态。
  主题(subject)是被观察的对象，依赖者(observer)是观察者，subject提供注册，移除，通知观察者的功能。
 
8.状态(State):允许对象在内部状态改变时改变它的行为，对象看起来好像修改了他所属的类。状态机

9.策略(Strategy):定义一系列算法，封装每个算法，并使它们可以互换。与状态模式类似，都能够动态改变对象的行为。状态模式解决状态转移问题，状态转移时，Context对象
  行为改变，策略模式主要用来封装一组互相替代的算法族，根据需要选择使用的算法。
  
10.模板方法(Template Method):定义算法框架，将一些步骤实现延迟到子类。子类可以重新定义算法步骤，不用改变算法的结构

11.访问者(Visitor):为一个对象结构增加新能力。

12.空对象(NULL):用什么都不做的一个对象来代替NULL，即定义一个提供方法但是什么也不做的空对象，省去NULL判断的步骤。


结构型：

1.适配器(Adapter):把一个类借口转换成另一个用户需要的接口

2.桥接(Bridge):把抽象和实现分离，使它们可以独立变化。

3.组合(Composite):将对象组合成树形结构来表示“整体/部分”层次关系，运行用户以相同的方式处理单独对象和组合对象。组合对象有一个或者多个组件对象，
       对组合对象的操作可以委托给组件对象处理。
	   
4.装饰器(Decorator):在不改变原对象的情况下，为对象动态添加功能。遵循：类应该对扩展开放，对修改关闭的原则。

5.外观(Facade):提供了一个统一的接口，用来访问子系统中的一群接口，让子系统更容易使用。遵循最少知识原则：客户对象所需要的交互对象应尽可能少。

6.享元(Flyweight)：利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。

7.代理(Proxy):控制对其他对象的访问。