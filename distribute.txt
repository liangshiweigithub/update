1.分布式锁：
  (1)Redis setNX， RedLock
  (2)Zookeeper：永久节点，有序节点，临时节点。
  步骤：创建锁目录。创建有序临时节点。判断自己节点是不是最小的节点，是则获得锁，
  不是则监控当前节点的前一个节点，直至获得锁。获得锁执行完事务后删除自己的节点。
  优势：创建的是临时节点，回话超时后其他节点可继续获取锁，不会出现死锁问题。
       为获得锁时，只需监控前一个节点，避免的羊群效应。
	   
2.分布式事务：事务操作位于不同节点上，需要保证事务的ACID特性。
  (1)2PC，两阶段提交，引入协调者协调参与者的行为，最终决定是否要真正执行事务。
     准备阶段：协调者询问参与者是否执行成功，参与者返回结果。
	 提交阶段：所有事务执行成功，协调者发布提交事务的命令，否则让参与者回滚事务。
	 问题：同步阻塞：参与者等待其他参与者响应时处于阻塞状态，无法进行其他操作。
	       协调者的单点问题。故障影响大，特别是第二阶段出故障时，所有参与者会一直等待
		   数据不一致：只有部分参与者收到commit信息时，只有部分参与者提交事务，引发数据不一致问题。
		   太保守：任意节点事务失败导致事务失败，没有完善容错机制。
   (2)3PC
    CanCommit：协调者向参与者发送包含事务内容的CanCommit请求，询问是否可以执行事务，等待回复。
	            参与者执行事务，并回复结果。
                若有参与者返回No，协调者发送abort请求	 
	preCommit：所有参与者返回yes，执行事务的提交过程。协调者发送Precommit请求，参与者执行事务操作，发回执行反馈。
	           若有参与者返回No，或者超时，会中断事务。协调者发出abort指令，接受者无论是否接收到abort指令，超时后都会中断事务
    doCommit：所有参与者均返回yes，执行提交，发送doCommit请求，接受者收到请求后，正式执行事务提交，发回反馈。
	          有参与者返回No或者超时：中断事务，向所有参与者发送abort指令，参与者回滚后发回反馈，协调者收到所有反馈后，完成事务中断
			  协调者，参与者出现问题，或者网络出现问题时，参与者在等待超时后，都会执行事务提交。
    有点：降低了阻塞范围，等待超时后协调者或参与者中断事务，避免单点问题。阶段3中如果协调者出现问题，超时后参与者会继续事务提交。
	缺点：协调者或者网络出现问题依然提交可能会导致数据不一致问题。