1.游戏中的AOI算法：
 (1)九宫格算法：每个格子维护其里面的对象信息，同时也需要维护关心该格子的观察者信息。
    缺点：用格子决定是否发送消息，一些不可见的角色也会被发送，有消息冗余。格子大小的划分问题。
 (2)十字链表算法：
    场景维护两个或三个双向链表，每个链表对象从小到大排列。当对象短距离移动时，节省计算量，若长距离移动，计算量会很大。
	根据链表中的位置，获得可视集合，发送add，leave或者move消息。
	每次移动都要更新角色在链表中的位置，浪费CPU

2.状态同步和帧同步：最大区别在于战斗核心逻辑的地方。
 (1)状态同步的战斗逻辑写在服务端，帧同步战斗逻辑在客户端。战斗逻辑包括技能逻辑，普工，属性，伤害，移动，ai，
    检测，碰撞等。核心逻辑必须知道一个场景中所有实体的情况，所以MMO游戏需要把战斗逻辑写在服务端，所以是状态同步的。
    MMO游戏客户端承载能力有限，不能把整张地图呈现，所以客户端没有足够信息计算全图人的行为。
    状态同步下，客户端更像一个表现层，不能更改数据。帧同步下，服务端只转发操作，不做逻辑处理。
 (2)流量：状态同步流量消耗更大，帧同步因为不需要同步属性，流量消耗小。
 (3)观战和回放：帧同步比较简单，只需要保存操作。状态同步则需要一个专门的服务器。、
 (4)安全性：状态同步因为逻辑和数据都在服务端，安全性更高。帧同步因为所有数据在客户端，作弊简单。
 (5)服务器压力：帧同步更大。状态服务器开发较难。
 (6)断线重连：状态同步更好做，根据服务端数值，将场景和人物重新生成一遍。帧同步比较麻烦，服务器把断线间的操作一次性发给
    客户端，客户端加速核心逻辑的运行速度，追上现有速度。
 (7)随机数种子：服务器统一生成发送。
  帧同步需要保证所有客户端每一帧输出一样，即同步性。相同输入有相同的输出,即确定性。

3.帧同步算法：
  LookSetp: 把游戏过程划分为一个个turn，只有当每个turn集齐了所有玩家的操作指令后，才进行计算，否则等待最慢的玩家
  bucket: 执行每一帧的时间是固定的 bucket 时间节点, 而不必等到收到所有的 client step 指令, 从而网络不再受最差的 client 限制
  Timewarp: 客户端先行，发现逻辑不一致的时候，进行回滚
  延迟补偿: 服务器端考虑了客户端的网络延迟，将服务器状态回滚到延迟前，再进行运算

4.帧同步如何防外挂：如果初始状态一样和随机种子一样，那么只要每帧的输入高度一样
  (因为是由服务器切帧分发的，可以保持每个客户端的输入序列是一样的)，那么每帧的运算结果也是一样的。
   为此让每个客户端验证每帧的结果是不是与其它几个客户端是一模一样的，我们就可以拿来做为校验原因。只要有不一样的结果，即有人做弊

5.帧同步的[所有人]的输入必须在[所有客户端]进行计算，这样大家运算出来的结果才能一样，才能保证帧同步.注意是【所有人】,
  所以常见用于rts，moba、2k等房间游戏.因为人数固定.但是mmo中玩家不定，如果同步所有人
  这个带宽(即传输问题)。。所以mmo中用状态同步+aoi视野管理.
