1.new,delete,malloc,free:
   new会调用构造函数，delete会调用析构函数，malloc和free则不会。new和delete是运算符，free和malloc是库函数。
   
2.子类析构函数调用顺序是先派生类的析构然后是基类的析构，构造时候相反。

3.多态：不同对象接收相同消息产生不同的动作。运行多态通过继承和虚函数实现，编译时多态通过函数重载实现。

4.虚函数：virtual关键字定义，允许基类重新定义。纯虚函数是作为借口存在的虚函数，不具有函数功能，不能直接被调用。如果一个类至少有一个纯虚函数，
   被称为抽象类。
   
5.引用是变量的别名，声明时要初始化。不是数据类型，引用本身不占用存储单元。不能建立数组的引用。
  与指针区别：引用必须初始化，指针不变，引用初始化之后本身不能再改变，不存在指向空值的引用，存在指向空值的指针。

6.常引用：const int &a = a.用来保护传递给函数的数据不在函数中被改变。

7.函数返回引用值时注意的问题：
  (1)不能返回局部变量的引用。局部变量会在返回后被销毁。
  (2)不要返回new分配内存的引用，可能会出现内存泄漏。
  (3)流操作符重载返回值声明为引用。
  
8.结构和联合体：
  (1)联合体中只存放一个被选中的成员，所有成员公用一块地址空间，结构体每个成员都有自己的内存空间，互不干扰。
  
10.重载和重写：
  (1)重载(overload)：多个函数同名，函数的参数列表不同(参数类型，参数个数).
  (2)子类重新定义父类虚函数的方法
  
11.c++不是类型安全的，两个不同类型的指针可以强制转换。

12.全局对象的构造会在main函数执行前。

13.内存分配方式：
  (1).静态存储区分配：程序运行前就已分配好，程序运行期间都存在，如全局变量，static变量。
  (2).栈上创建：函数局部变量的存储单元，函数执行结束紫铜释放。
  (3)堆上分配：动态内存分配，malloc和new的对象存储地，易发生内存泄漏。
  
14.const比#define的有点：const有数据类型，编译器可进行安全检查，而#define只进行字符替换，const常亮可以调试，#define则能。
  