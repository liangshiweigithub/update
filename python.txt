1.GIL: global interpreter lock,全局解释器锁。并不是python的特性，而是
  实现python解释器（CPython）是引入的概念。其他实现可能没有。原因是
  CPython的内存管理不是线程安全的。
  线程的执行必须先获得GIL，GIL只有一个，所以同一时间只有一个线程在执行。
  GIL在线程遇见IO操作或者计数达到100时，会切换执行进程。所以python对IO密集型更友好。
  cpu密集型由于获取GIL实现的缺陷，在多核多线程下性能更差，释放锁的线程大概率会马上再拿到GIL，其他CPU
  上唤醒的线程等待到切换时间后没有GIL又进入待调度状态，造成线程颠簸。
  解决方案：
  (1):多进程方案。
  (2):其他python解释器。
  (3):python3的优化：GIL释放从tick计数改为基于时间，避免CPU释放GIL后再次获得，线程优先级的加入。